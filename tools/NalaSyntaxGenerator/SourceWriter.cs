// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Xml;
using NalaSyntaxGenerator.Model;

namespace NalaSyntaxGenerator
{
    internal class SourceWriter : AbstractFileWriter
    {
        private SourceWriter(TextWriter writer, Tree tree)
            : base(writer, tree)
        {
        }

        public static void WriteMain(TextWriter writer, Tree tree) => new SourceWriter(writer, tree).WriteMain();

        public static void WriteSyntax(TextWriter writer, Tree tree) => new SourceWriter(writer, tree).WriteSyntax();

        public static void WriteParsers(TextWriter writer, Tree tree) => new SourceWriter(writer, tree).WriteParsers();

        private void WriteFileHeader()
        {
            WriteLine("// <auto-generated />");
            WriteLine();
            WriteLine("using System;");
            WriteLine("using System.Collections;");
            WriteLine("using System.Collections.Generic;");
            WriteLine("using System.Linq;");
            WriteLine("using System.Threading;");
            WriteLine();
        }

        private void WriteParsers()
        {
            WriteFileHeader();
            WriteLine("using GosuParser;");
            WriteLine("using static GosuParser.Parser;");
            WriteLine("using Nala.Syntax;");
            WriteLine();

            WriteLine("namespace Nala");
            WriteLine("{");

            WriteLine("    public partial class NalaParser");
            WriteLine("    {");

            this.WriteTokenParserTypes();
            this.WriteAbstractParserTypes();
            this.WriteParserTypes();
            WriteLine("    }");
            WriteLine("}");
        }

        private string ToStringLiteral(string value)
        {
            return value.Replace(@"\", @"\\").Replace("\"", "\\\"").Replace("\'", "\\\'");
        }

        private void WriteTokenParserTypes()
        {
            var tokens = Tree.Tokens;
            foreach (var token in tokens)
            {
                WriteLine("        public static Parser<SyntaxToken> {0}Parser =>", token.Name);
                WriteLine("            from _ in SyntaxTriviaParser");
                if (token.Content.Length == 1)
                {
                    WriteLine("            from s in Char(\'{0}\')", ToStringLiteral(token.Content));
                }
                else
                {
                    WriteLine("            from s in String(\"{0}\")", ToStringLiteral(token.Content));
                }
                WriteLine("            from __ in SyntaxTriviaParser");
                WriteLine("            select new SyntaxToken(SyntaxKind.{0});", token.Name);
                WriteLine();
            }
        }


        private void WriteAbstractParserTypes()
        {
            var abstractNodes = Tree.Types.Where(n => n is AbstractNode).Cast<AbstractNode>().ToList();
            var concreteNodes = Tree.Types.Where(n => abstractNodes.Any(abs => abs.Name == n.Base)).ToList();

            for (int i = 0, n = abstractNodes.Count; i < n; i++)
            {
                var node = abstractNodes[i];
                WriteLine();
                this.WriteAbstractParserType(node, concreteNodes.Where(concrete => concrete.Base == node.Name).ToList());
            }
        }

        private void WriteAbstractParserType(AbstractNode node, List<TreeType> concreteNodes)
        {
            if (concreteNodes.Count == 1)
            {
                WriteLine("        public static Parser<{0}> {1}Parser =>", node.Name, StripPost(node.Name, "Syntax"));
                var name = StripPost(concreteNodes[0].Name, "Syntax");
                var camelCase = CamelCase(name);
                WriteLine("            from {0} in {1}Parser", camelCase, name);
                WriteLine("            select ({0}){1};", node.Name, camelCase);
                
            }
            else
            {
                WriteLine("        public static Parser<{0}> {1}Parser =>", node.Name, StripPost(node.Name, "Syntax"));
                WriteLine("            new Parser<{0}>[] {{ ", node.Name);
                WriteWithLineSeperator(concreteNodes, concreteNode =>
                {
                    Write("                {0}Parser.Select(x => ({1})x).Trace(\"{0}\")", StripPost(concreteNode.Name, "Syntax"), node.Name);
                });
                WriteLine("           }.Choice();");
            }
        }

        private void WriteParserTypes()
        {
            var nodes = Tree.Types.Where(n => n is Node).Cast<Node>().ToList();
            for (int i = 0, n = nodes.Count; i < n; i++)
            {
                var node = nodes[i];
                WriteLine();
                this.WriteParserType(node);
            }
        }

        private bool TraceParsers = true;
        private void WriteParserType(Node node)
        {
            Console.WriteLine("Processing "+ node.Name);
            var kindField = node.Fields.FirstOrDefault(f => f.Kinds.Count > 1);
            var multiKind = kindField != null && node.Kinds.Count > 1;
            if (!multiKind)
            {
                kindField = null;
            }

            WriteLine("        public static Parser<{0}> {1}Parser =>", node.Name, StripPost(node.Name, "Syntax"));
            foreach (var field in node.Fields)
            {
                if (field.Type == "SyntaxToken")
                {
                    switch (field.Kinds.Count)
                    {
                        case 1:
                            Write("            from {0} in {1}Parser", CamelCase(field.Name), field.Kinds.First().Name);
                            if (IsOptional(field))
                            {
                                Write(".OrElse(NoneParser)");
                            }
                            break;
                        case 2:
                            var firstKind = field.Kinds.First();
                            var secondKind = field.Kinds.Skip(1).First();

                            if (multiKind && field == kindField)
                            {
                                WriteLine("            from {0} in Parser.OrElse(", CamelCase(field.Name));
                                WriteLine("                {0}Parser.Select(token => new {{token, kind=SyntaxKind.{1}}}),", firstKind.Name, firstKind.ParentKind);
                                WriteLine("                {0}Parser.Select(token => new {{token, kind=SyntaxKind.{1}}})", secondKind.Name, secondKind.ParentKind);
                                Write("                )");
                            }
                            else
                            {
                                Write("            from {0} in {1}Parser.OrElse({2}Parser)", CamelCase(field.Name),
                                    firstKind.Name,
                                    secondKind.Name);
                            }
                            break;
                        default:
                            Write("            from {0} in new [] {{", CamelCase(field.Name));
                            if (multiKind && field == kindField)
                            {
                                WriteWithSeperator(field.Kinds, kind =>
                                {
                                    Write("                {0}Parser.Select(token => new {{token, kind = SyntaxKind.{1}}})",
                                        kind.Name, kind.ParentKind);
                                });
                            }
                            else
                            {
                                WriteWithSeperator(field.Kinds, kind =>
                                {
                                    Write("{0}Parser", kind.Name);
                                    if(TraceParsers)
                                        Write(".Trace(\"{0}\")", kind.Name);
                                });
                            }
                            Write("            }.Choice()");
                            break;
                    }
                }
                else if (IsNodeList(field.Type))
                {
                    var innerType = GetInnerType(field.Type);
                    if (innerType == "SyntaxToken")
                    {
                        Write("            from {0} in SyntaxTokenListParser", CamelCase(field.Name));
                    }
                    else
                    {
                        Write("            from {0} in SyntaxListParser({1}Parser)", CamelCase(field.Name), StripPost(innerType, "Syntax"));
                        if(TraceParsers)
                            Write(".Trace(\"{0}\")", StripPost(innerType, "Syntax"));
                    }
                }
                else if (IsSeparatedNodeList(field.Type))
                {
                    Write("            from {0} in SeparatedSyntaxListParser<{1}>()", CamelCase(field.Name),
                        GetInnerType(field.Type));
                }
                else
                {
                    Write("            from {0} in {1}Parser{2}", CamelCase(field.Name),
                        StripPost(field.Type, "Syntax"), field.Optional == "true" ? ".ZeroOrOne()" : "");

                    if (TraceParsers)
                        Write(".Trace(\"{0}\")", StripPost(field.Type, "Syntax"));
                }

                WriteLine(field.TriviaType);
            }

            Write("            select SyntaxFactory.{0}(", StripPost(node.Name, "Syntax"));
            if (multiKind)
            {
                Write("{0}.kind, ", CamelCase(kindField.Name));
            }

            WriteWithSeperator(", ", node.Fields, field =>
            {
                var suffix = IsOptional(field) && field.Type != "SyntaxToken" ? ".FirstOrDefault()" : "";
                Write(CamelCase(field.Name));
                if (field == kindField)
                {
                    Write(".token");
                }
                Write(suffix);
            });
            WriteLine(");");
        }



        private static string GetInnerType(string type)
        {
            var listLength = type.IndexOf("<", StringComparison.Ordinal);
            var innerType = type.Substring(listLength + 1, type.Length - listLength - 2);
            return innerType;
        }

        private void WriteSyntax()
        {
            WriteFileHeader();

            WriteLine();
            WriteLine("namespace Nala.Syntax");
            WriteLine("{");
            WriteLine();
            this.WriteRedTypes();
            WriteLine("}");
        }

        private void WriteMain()
        {
            WriteFileHeader();

            WriteLine();
            WriteLine("namespace Nala");
            WriteLine("{");
            WriteLine("    using Nala.Syntax;");
            WriteLine();
            this.WriteRedVisitors();
            this.WriteRedRewriter();
            this.WriteRedFactories();
            WriteLine("}");
        }

        private void WriteGreenNodeConstructorArgs(List<Field> nodeFields, List<Field> valueFields)
        {
            for (int i = 0, n = nodeFields.Count; i < n; i++)
            {
                var field = nodeFields[i];
                string type = GetFieldType(field, green: false);
                
                Write(", {0} {1}", type, CamelCase(field.Name));
            }

            for (int i = 0, n = valueFields.Count; i < n; i++)
            {
                var field = valueFields[i];
                Write(", {0} {1}", field.Type, CamelCase(field.Name));
            }
        }

        private void WriteCtorBody(List<Field> valueFields, List<Field> nodeFields)
        {
            // constructor body
            WriteLine("        this.SlotCount = {0};", nodeFields.Count);
            for (int i = 0, n = nodeFields.Count; i < n; i++)
            {
                var field = nodeFields[i];
                WriteLine("        this.{0} = {0};", CamelCase(field.Name));
            }

            for (int i = 0, n = valueFields.Count; i < n; i++)
            {
                var field = valueFields[i];
                WriteLine("        this.{0} = {0};", CamelCase(field.Name));
            }
        }
        
        private void WriteCtorArgList(Node nd, bool withSyntaxFactoryContext, List<Field> valueFields, List<Field> nodeFields)
        {
            if (nd.Kinds.Count == 1)
            {
                Write("SyntaxKind.");
                Write(nd.Kinds[0].Name);
            }
            else
            {
                Write("kind");
            }
            for (int i = 0, n = nodeFields.Count; i < n; i++)
            {
                var field = nodeFields[i];
                Write(", ");
                if (field.Type == "SyntaxList<SyntaxToken>" || IsAnyList(field.Type))
                {
                    Write("{0}.Node", CamelCase(field.Name));
                }
                else
                {
                    Write(CamelCase(field.Name));
                }
            }
            // values are at end
            for (int i = 0, n = valueFields.Count; i < n; i++)
            {
                var field = valueFields[i];
                Write(", ");
                Write(CamelCase(field.Name));
            }
            if (withSyntaxFactoryContext)
            {
                Write(", this.context");
            }
        }

        private void WriteRedTypes()
        {
            var nodes = Tree.Types.Where(n => !(n is PredefinedNode)).ToList();
            for (int i = 0, n = nodes.Count; i < n; i++)
            {
                var node = nodes[i];
                WriteLine();
                this.WriteRedType(node);
            }
        }

        private void WriteRedType(TreeType node)
        {
            WriteComment(node.TypeComment, "  ");

            if (node is AbstractNode)
            {
                AbstractNode nd = (AbstractNode)node;
                WriteLine("  public abstract partial class {0} : {1}", node.Name, node.Base);
                WriteLine("  {");
                WriteLine("    internal {0}(SyntaxKind kind)", node.Name);
                WriteLine("      : base(kind)");
                WriteLine("    {");
                if (node.Name == "DirectiveTriviaSyntax")
                {
                    WriteLine("      this.flags |= NodeFlags.ContainsDirectives;");
                }
                WriteLine("    }");

                var valueFields = nd.Fields.Where(n => !IsNodeOrNodeList(n.Type)).ToList();
                var nodeFields = nd.Fields.Where(n => IsNodeOrNodeList(n.Type)).ToList();

                for (int i = 0, n = nodeFields.Count; i < n; i++)
                {
                    var field = nodeFields[i];
                    if (IsNodeOrNodeList(field.Type))
                    {
                        //red SyntaxLists can't contain tokens, so we switch to SyntaxTokenList
                        var fieldType = field.Type == "SyntaxList<SyntaxToken>" ? "SyntaxTokenList" : field.Type;
                        WriteLine();
                        WriteComment(field.PropertyComment, "    ");
                        WriteLine("    {0} abstract {1}{2} {3} {{ get; }}", "public", (IsNew(field) ? "new " : ""), fieldType, field.Name);
                    }
                }

                for (int i = 0, n = valueFields.Count; i < n; i++)
                {
                    var field = valueFields[i];
                    WriteLine();
                    WriteComment(field.PropertyComment, "    ");
                    WriteLine("    {0} abstract {1}{2} {3} {{ get; }}", "public", (IsNew(field) ? "new " : ""), field.Type, field.Name);
                }

                WriteLine("  }");
            }
            else if (node is Node)
            {
                Node nd = (Node)node;
                WriteLine("  public sealed partial class {0} : {1}", node.Name, node.Base);
                WriteLine("  {");

                var valueFields = nd.Fields.Where(n => !IsNodeOrNodeList(n.Type)).ToList();
                var nodeFields = nd.Fields.Where(n => IsNodeOrNodeList(n.Type)).ToList();

                for (int i = 0, n = nodeFields.Count; i < n; i++)
                {
                    var field = nodeFields[i];
                    var type = GetFieldType(field, green: false);
                    WriteLine("    private readonly {0} {1};", type, CamelCase(field.Name));
                }

                for (int i = 0, n = valueFields.Count; i < n; i++)
                {
                    var field = valueFields[i];
                    WriteLine("    private readonly {0} {1};", field.Type, CamelCase(field.Name));
                }

                // write constructor
                WriteLine();
                Write("    internal {0}(SyntaxKind kind", node.Name);

                WriteGreenNodeConstructorArgs(nodeFields, valueFields);

                WriteLine(")");
                WriteLine("        : base(kind)");
                WriteLine("    {");
                WriteCtorBody(valueFields, nodeFields);
                WriteLine("    }");
                WriteLine();

                // property accessors
                for (int i = 0, n = nodeFields.Count; i < n; i++)
                {
                    var field = nodeFields[i];
                    if (field.Type == "SyntaxToken")
                    {
                        WriteComment(field.PropertyComment, "    ");
                        WriteLine("    {0} {1}{2} {3} ", "public", OverrideOrNewModifier(field), field.Type, field.Name);
                        WriteLine("    {");
                        if (IsOptional(field))
                        {
                            WriteLine("        get");
                            WriteLine("        {");
                            WriteLine("            return this.{0};", CamelCase(field.Name));
                            WriteLine("        }");
                        }
                        else
                        {
                            WriteLine("      get {{ return this.{0}; }}", CamelCase(field.Name));
                        }
                        WriteLine("    }");
                    }
                    else if (field.Type == "SyntaxList<SyntaxToken>")
                    {
                        WriteComment(field.PropertyComment, "    ");
                        WriteLine("    {0} {1}SyntaxTokenList {2} ", "public", OverrideOrNewModifier(field), field.Name);
                        WriteLine("    {");
                        WriteLine("        get");
                        WriteLine("        {");
                        WriteLine("            var slot = this.{0};", CamelCase(field.Name));
                        WriteLine("            if (slot != null)");
                        WriteLine("                return new SyntaxTokenList(this, slot);");
                        WriteLine();
                        WriteLine("            return default(SyntaxTokenList);");
                        WriteLine("        }");
                        WriteLine("    }");
                    }
                    else
                    {
                        WriteComment(field.PropertyComment, "    ");
                        WriteLine("    {0} {1}{2} {3} ", "public", OverrideOrNewModifier(field), field.Type, field.Name);
                        WriteLine("    {");
                        WriteLine("        get");
                        WriteLine("        {");

                        if (IsNodeList(field.Type))
                        {
                            WriteLine("            return new {0}(this.{1});", field.Type, CamelCase(field.Name));
                        }
                        else if (IsSeparatedNodeList(field.Type))
                        {
                            WriteLine("            var red = this.{0};", CamelCase(field.Name));
                            WriteLine("            if (red != null)", i);
                            WriteLine("                return new {0}(red);", field.Type);
                            WriteLine();
                            WriteLine("            return default({0});", field.Type);
                        }
                        else if (field.Type == "SyntaxNodeOrTokenList")
                        {
                            throw new InvalidOperationException("field cannot be a random SyntaxNodeOrTokenList");
                        }
                        else
                        {
                            if (i == 0)
                            {
                                WriteLine("            return this.{0};", CamelCase(field.Name));
                            }
                            else
                            {
                                WriteLine("            return this.{0};", CamelCase(field.Name));
                            }
                        }
                        WriteLine("        }");
                        WriteLine("    }");
                    }
                    WriteLine();
                }

                for (int i = 0, n = valueFields.Count; i < n; i++)
                {
                    var field = valueFields[i];
                    WriteComment(field.PropertyComment, "    ");
                    WriteLine("    public {0}{1} {2} {{ get {{ return this.{3}; }} }}",
                        OverrideOrNewModifier(field), field.Type, field.Name, CamelCase(field.Name)
                        );
                }

                WriteLine("    internal override SyntaxNode GetSlot(int index)");
                WriteLine("    {");
                WriteLine("        switch (index)");
                WriteLine("        {");
                for (int i = 0, n = nodeFields.Count; i < n; i++)
                {
                    var field = nodeFields[i];

                    if (field.Type != "SyntaxToken" && field.Type != "SyntaxList<SyntaxToken>")
                    {
                        WriteLine("            case {0}: return this.{1};", i, CamelCase(field.Name));
                    }
                }
                WriteLine("            default: return null;");
                WriteLine("        }");
                WriteLine("    }");

                this.WriteRedAcceptMethods(nd);
                this.WriteRedUpdateMethod(nd);
                // this.WriteRedWithMethod(nd);
                this.WriteRedSetters(nd);
                this.WriteRedListHelperMethods(nd);

                WriteLine("  }");
            }
        }
        
        private void WriteRedAcceptMethods(Node node)
        {
            WriteRedAcceptMethod(node, false, true);
            WriteRedAcceptMethod(node, false, false);
        }

        private void WriteRedAcceptMethod(Node node, bool genericArgument, bool genericResult)
        {
            string genericArgs =
                (genericResult && genericArgument) ? "<TArgument, TResult>" :
                genericResult ? "<TResult>" : "";
            WriteLine();
            WriteLine("    public override " + (genericResult ? "TResult" : "void") + " Accept" + genericArgs + "(SyntaxVisitor" + genericArgs + " visitor{0})", genericArgument ? ", TArgument argument" : "");
            WriteLine("    {");
            WriteLine("        " + (genericResult ? "return " : "") + "visitor.Visit{0}(this{1});", StripPost(node.Name, "Syntax"), genericArgument ? ", argument" : "");
            WriteLine("    }");
        }

        private void WriteRedVisitors()
        {
            WriteRedVisitor(false, true);
            WriteRedVisitor(false, false);
        }

        private void WriteRedVisitor(bool genericArgument, bool genericResult)
        {
            string genericArgs =
                (genericResult && genericArgument) ? "<TArgument, TResult>" :
                genericResult ? "<TResult>" : "";
            var nodes = Tree.Types.Where(n => !(n is PredefinedNode)).ToList();

            WriteLine();
            WriteLine("  public partial class SyntaxVisitor" + genericArgs);
            WriteLine("  {");
            int nWritten = 0;
            for (int i = 0, n = nodes.Count; i < n; i++)
            {
                var node = nodes[i] as Node;
                if (node != null)
                {
                    if (nWritten > 0)
                        WriteLine();
                    nWritten++;
                    WriteComment(string.Format("<summary>Called when the visitor visits a {0} node.</summary>", node.Name), "    ");
                    WriteLine("    public virtual " + (genericResult ? "TResult" : "void") + " Visit{0}({1} node{2})", StripPost(node.Name, "Syntax"), node.Name, genericArgument ? ", TArgument argument" : "");
                    WriteLine("    {");
                    WriteLine("      " + (genericResult ? "return " : "") + "this.DefaultVisit(node{0});", genericArgument ? ", argument" : "");
                    WriteLine("    }");
                }
            }
            WriteLine("  }");
        }

        private void WriteRedUpdateMethod(Node node)
        {
            WriteLine();
            Write("    {0} {1} Update(", "public", node.Name);

            // parameters
            for (int f = 0; f < node.Fields.Count; f++)
            {
                var field = node.Fields[f];
                if (f > 0)
                    Write(", ");
                var type = field.Type == "SyntaxList<SyntaxToken>" ? "SyntaxTokenList" : field.Type;
                Write("{0} {1}", type, CamelCase(field.Name));
            }
            WriteLine(")");
            WriteLine("    {");

            Write("        if (");
            int nCompared = 0;
            for (int f = 0; f < node.Fields.Count; f++)
            {
                var field = node.Fields[f];
                if (IsDerivedOrListOfDerived("SyntaxNode", field.Type) || IsDerivedOrListOfDerived("SyntaxToken", field.Type) || field.Type == "SyntaxNodeOrTokenList")
                {
                    if (nCompared > 0)
                        Write(" || ");
                    Write("{0} != this.{1}", CamelCase(field.Name), field.Name);
                    nCompared++;
                }
            }
            if (nCompared > 0)
            {
                WriteLine(")");
                WriteLine("        {");
                Write("            return SyntaxFactory.{0}(", StripPost(node.Name, "Syntax"));
                if (node.Kinds.Count > 1)
                {
                    Write("this.Kind, ");
                }
                for (int f = 0; f < node.Fields.Count; f++)
                {
                    var field = node.Fields[f];
                    if (f > 0)
                        Write(", ");
                    Write(CamelCase(field.Name));
                }
                WriteLine(");");
                WriteLine("        }");
            }

            WriteLine();
            WriteLine("        return this;");
            WriteLine("    }");
        }
        
        private void WriteRedSetters(Node node)
        {
            for (int f = 0; f < node.Fields.Count; f++)
            {
                var field = node.Fields[f];
                var type = this.GetRedPropertyType(field);

                WriteLine();
                WriteLine("    {0} {1} With{2}({3} {4})", "public", node.Name, StripPost(field.Name, "Opt"), type, CamelCase(field.Name));
                WriteLine("    {");

                // call update inside each setter
                Write("        return this.Update(");
                for (int f2 = 0; f2 < node.Fields.Count; f2++)
                {
                    var field2 = node.Fields[f2];
                    if (f2 > 0)
                        Write(", ");

                    if (field2 == field)
                    {
                        this.Write("{0}", CamelCase(field2.Name));
                    }
                    else
                    {
                        this.Write("this.{0}", field2.Name);
                    }
                }
                WriteLine(");");

                WriteLine("    }");
            }
        }

        private void WriteRedListHelperMethods(Node node)
        {
            for (int f = 0; f < node.Fields.Count; f++)
            {
                var field = node.Fields[f];
                if (IsAnyList(field.Type))
                {
                    // write list helper methods for list properties
                    WriteRedListHelperMethods(node, field);
                }
                else
                {
                    Node referencedNode = GetNode(field.Type);
                    if (referencedNode != null && (!IsOptional(field) || RequiredFactoryArgumentCount(referencedNode) == 0))
                    {
                        // look for list members...
                        for (int rf = 0; rf < referencedNode.Fields.Count; rf++)
                        {
                            var referencedNodeField = referencedNode.Fields[rf];
                            if (IsAnyList(referencedNodeField.Type))
                            {
                                WriteRedNestedListHelperMethods(node, field, referencedNode, referencedNodeField);
                            }
                        }
                    }
                }
            }
        }

        private void WriteRedListHelperMethods(Node node, Field field)
        {
            var argType = GetElementType(field.Type);
            WriteLine();
            WriteLine("    public {0} Add{1}(params {2}[] items)", node.Name, field.Name, argType);
            WriteLine("    {");
            WriteLine("        return this.With{0}(this.{1}.AddRange(items));", StripPost(field.Name, "Opt"), field.Name);
            WriteLine("    }");
        }

        private void WriteRedNestedListHelperMethods(Node node, Field field, Node referencedNode, Field referencedNodeField)
        {
            var argType = GetElementType(referencedNodeField.Type);

            // AddBaseListTypes
            WriteLine();
            WriteLine("    public {0} Add{1}{2}(params {3}[] items)", node.Name, StripPost(field.Name, "Opt"), referencedNodeField.Name, argType);
            WriteLine("    {");

            if (IsOptional(field))
            {
                var factoryName = StripPost(referencedNode.Name, "Syntax");
                var varName = StripPost(CamelCase(field.Name), "Opt");
                WriteLine("        var {0} = this.{1} ?? SyntaxFactory.{2}();", varName, field.Name, factoryName);
                WriteLine("        return this.With{0}({1}.With{2}({1}.{3}.AddRange(items)));", StripPost(field.Name, "Opt"), varName, StripPost(referencedNodeField.Name, "Opt"), referencedNodeField.Name);
            }
            else
            {
                WriteLine("        return this.With{0}(this.{1}.With{2}(this.{1}.{3}.AddRange(items)));", StripPost(field.Name, "Opt"), field.Name, StripPost(referencedNodeField.Name, "Opt"), referencedNodeField.Name);
            }

            WriteLine("    }");
        }

        private void WriteRedRewriter()
        {
            var nodes = Tree.Types.Where(n => !(n is PredefinedNode)).ToList();

            WriteLine();
            WriteLine("  public partial class SyntaxRewriter : SyntaxVisitor<SyntaxNode>");
            WriteLine("  {");
            int nWritten = 0;
            for (int i = 0, n = nodes.Count; i < n; i++)
            {
                var node = nodes[i] as Node;
                if (node != null)
                {
                    var nodeFields = node.Fields.Where(nd => IsNodeOrNodeList(nd.Type)).ToList();

                    if (nWritten > 0)
                        WriteLine();
                    nWritten++;
                    WriteLine("    public override SyntaxNode Visit{0}({1} node)", StripPost(node.Name, "Syntax"), node.Name);
                    WriteLine("    {");
                    for (int f = 0; f < nodeFields.Count; f++)
                    {
                        var field = nodeFields[f];
                        if (IsAnyList(field.Type))
                        {
                            WriteLine("      var {0} = this.VisitList(node.{1});", CamelCase(field.Name), field.Name);
                        }
                        else if (field.Type == "SyntaxToken")
                        {
                            WriteLine("      var {0} = this.VisitToken(node.{1});", CamelCase(field.Name), field.Name);
                        }
                        else
                        {
                            WriteLine("      var {0} = ({1})this.Visit(node.{2});", CamelCase(field.Name), field.Type, field.Name);
                        }
                    }
                    if (nodeFields.Count > 0)
                    {
                        Write("      return node.Update(");
                        for (int f = 0; f < node.Fields.Count; f++)
                        {
                            var field = node.Fields[f];
                            if (f > 0)
                                Write(", ");
                            if (IsNodeOrNodeList(field.Type))
                            {
                                Write(CamelCase(field.Name));
                            }
                            else
                            {
                                Write("node.{0}", field.Name);
                            }
                        }
                        WriteLine(");");
                    }
                    else
                    {
                        WriteLine("      return node;");
                    }
                    WriteLine("    }");
                }
            }
            WriteLine("  }");
        }

        private void WriteRedFactories()
        {
            var nodes = Tree.Types.Where(n => !(n is PredefinedNode) && !(n is AbstractNode)).OfType<Node>().ToList();
            WriteLine();
            WriteLine("  public static partial class SyntaxFactory");
            WriteLine("  {");

            for (int i = 0, n = nodes.Count; i < n; i++)
            {
                var node = nodes[i];
                this.WriteRedFactory(node);
                this.WriteRedFactoryWithNoAutoCreatableTokens(node);
                this.WriteRedMinimalFactory(node);
                this.WriteRedMinimalFactory(node, withStringNames: true);
                this.WriteKindConverters(node);
            }

            WriteLine("  }");
        }

        protected bool CanBeAutoCreated(Node node, Field field)
        {
            return IsAutoCreatableToken(node, field) || IsAutoCreatableNode(node, field);
        }

        private bool IsAutoCreatableToken(Node node, Field field)
        {
            return field.Type == "SyntaxToken"
                && field.Kinds != null
                && ((field.Kinds.Count == 1 && field.Kinds[0].Name != "IdentifierToken" && !field.Kinds[0].Name.EndsWith("LiteralToken", StringComparison.Ordinal)) || (field.Kinds.Count > 1 && field.Kinds.Count == node.Kinds.Count));
        }

        private bool IsAutoCreatableNode(Node node, Field field)
        {
            var referencedNode = GetNode(field.Type);
            return (referencedNode != null && RequiredFactoryArgumentCount(referencedNode) == 0);
        }

        private bool IsRequiredFactoryField(Node node, Field field)
        {
            return (!IsOptional(field) && !IsAnyList(field.Type) && !CanBeAutoCreated(node, field)) || IsValueField(field);
        }

        private bool IsValueField(Field field)
        {
            return !IsNodeOrNodeList(field.Type);
        }

        private int RequiredFactoryArgumentCount(Node nd, bool includeKind = true)
        {
            int count = 0;

            // kind must be specified in factory
            if (nd.Kinds.Count > 1 && includeKind)
            {
                count++;
            }

            for (int i = 0, n = nd.Fields.Count; i < n; i++)
            {
                var field = nd.Fields[i];
                if (IsRequiredFactoryField(nd, field))
                {
                    count++;
                }
            }

            return count;
        }

        private int OptionalFactoryArgumentCount(Node nd)
        {
            int count = 0;
            for (int i = 0, n = nd.Fields.Count; i < n; i++)
            {
                var field = nd.Fields[i];
                if (IsOptional(field) || CanBeAutoCreated(nd, field) || IsAnyList(field.Type))
                {
                    count++;
                }
            }

            return count;
        }

        // full factory signature with nothing optional
        private void WriteRedFactory(Node nd)
        {
            this.WriteLine();

            var valueFields = nd.Fields.Where(n => IsValueField(n)).ToList();
            var nodeFields = nd.Fields.Where(n => !IsValueField(n)).ToList();

            WriteComment(string.Format("<summary>Creates a new {0} instance.</summary>", nd.Name), "    ");

            Write("    {0} static {1} {2}(", "public", nd.Name, StripPost(nd.Name, "Syntax"));
            WriteRedFactoryParameters(nd);

            WriteLine(")");
            WriteLine("    {");

            // validate kinds
            if (nd.Kinds.Count > 1)
            {
                WriteLine("      switch (kind)");
                WriteLine("      {");
                foreach (var kind in nd.Kinds)
                {
                    WriteLine("        case SyntaxKind.{0}:", kind.Name);
                }
                WriteLine("          break;");
                WriteLine("        default:");
                WriteLine("          throw new ArgumentException(\"kind\");");
                WriteLine("      }");
            }

            // validate parameters
            for (int i = 0, n = nodeFields.Count; i < n; i++)
            {
                var field = nodeFields[i];
                var pname = CamelCase(field.Name);

                if (field.Type == "SyntaxToken")
                {
                    if (field.Kinds != null && field.Kinds.Count > 0)
                    {
                        WriteLine("      switch ({0}.Kind)", pname);
                        WriteLine("      {");
                        foreach (var kind in field.Kinds)
                        {
                            WriteLine("        case SyntaxKind.{0}:", kind.Name);
                        }
                        if (IsOptional(field))
                        {
                            WriteLine("        case SyntaxKind.None:");
                        }
                        WriteLine("          break;");
                        WriteLine("        default:");
                        WriteLine("          throw new ArgumentException(\"{0}\");", pname);
                        WriteLine("      }");
                    }
                }
                else if (!IsAnyList(field.Type) && !IsOptional(field))
                {
                    WriteLine("      if ({0} == null)", CamelCase(field.Name));
                    WriteLine("        throw new ArgumentNullException(nameof({0}));", CamelCase(field.Name));
                }
            }

            Write("      return new {0}(", nd.Name);
            WriteCtorArgList(nd, false, valueFields, nodeFields);
            WriteLine(");");

            WriteLine("    }");
            this.WriteLine();
        }

        private void WriteRedFactoryParameters(Node nd)
        {
            if (nd.Kinds.Count > 1)
            {
                Write("SyntaxKind kind, ");
            }

            for (int i = 0, n = nd.Fields.Count; i < n; i++)
            {
                var field = nd.Fields[i];
                if (i > 0)
                    Write(", ");
                var type = this.GetRedPropertyType(field);

                Write("{0} {1}", type, CamelCase(field.Name));
            }
        }

        private string GetRedPropertyType(Field field)
        {
            if (field.Type == "SyntaxList<SyntaxToken>")
                return "SyntaxTokenList";
            return field.Type;
        }

        private string GetDefaultValue(Node nd, Field field)
        {
            System.Diagnostics.Debug.Assert(!IsRequiredFactoryField(nd, field));

            if (IsOptional(field) || IsAnyList(field.Type))
            {
                return string.Format("default({0})", GetRedPropertyType(field));
            }
            else if (field.Type == "SyntaxToken")
            {
                // auto construct token?
                if (field.Kinds.Count == 1)
                {
                    return string.Format("SyntaxFactory.Token(SyntaxKind.{0})", field.Kinds[0].Name);
                }
                else
                {
                    return string.Format("SyntaxFactory.Token(Get{0}{1}Kind(kind))", StripPost(nd.Name, "Syntax"), StripPost(field.Name, "Opt"));
                }
            }
            else
            {
                var referencedNode = GetNode(field.Type);
                return string.Format("SyntaxFactory.{0}()", StripPost(referencedNode.Name, "Syntax"));
            }
        }

        // Writes Get<Property>Kind() methods for converting between node kind and member token kinds...
        private void WriteKindConverters(Node nd)
        {
            for (int f = 0; f < nd.Fields.Count; f++)
            {
                var field = nd.Fields[f];

                if (field.Type == "SyntaxToken" && CanBeAutoCreated(nd, field) && field.Kinds.Count > 1)
                {
                    WriteLine();
                    WriteLine("    private static SyntaxKind Get{0}{1}Kind(SyntaxKind kind)", StripPost(nd.Name, "Syntax"), StripPost(field.Name, "Opt"));
                    WriteLine("    {");

                    WriteLine("      switch (kind)");
                    WriteLine("      {");

                    for (int k = 0; k < field.Kinds.Count; k++)
                    {
                        var nKind = nd.Kinds[k];
                        var pKind = field.Kinds[k];
                        WriteLine("        case SyntaxKind.{0}:", nKind.Name);
                        WriteLine("          return SyntaxKind.{0};", pKind.Name);
                    }

                    WriteLine("        default:");
                    WriteLine("          throw new ArgumentOutOfRangeException();");
                    WriteLine("      }");
                    WriteLine("    }");
                }
            }
        }

        private IEnumerable<Field> DetermineRedFactoryWithNoAutoCreatableTokenFields(Node nd)
        {
            return nd.Fields.Where(f => !IsAutoCreatableToken(nd, f));
        }

        // creates a factory without auto-creatable token arguments
        private void WriteRedFactoryWithNoAutoCreatableTokens(Node nd)
        {
            var nAutoCreatableTokens = nd.Fields.Count(f => IsAutoCreatableToken(nd, f));
            if (nAutoCreatableTokens == 0)
                return; // already handled by general factory

            var factoryWithNoAutoCreatableTokenFields = new HashSet<Field>(DetermineRedFactoryWithNoAutoCreatableTokenFields(nd));
            var minimalFactoryFields = DetermineMinimalFactoryFields(nd);
            if (minimalFactoryFields != null && factoryWithNoAutoCreatableTokenFields.SetEquals(minimalFactoryFields))
            {
                return; // will be handled in minimal factory case
            }

            this.WriteLine();

            WriteComment(string.Format("<summary>Creates a new {0} instance.</summary>", nd.Name), "    ");
            Write("    {0} static {1} {2}(", "public", nd.Name, StripPost(nd.Name, "Syntax"));

            bool hasPreviousParameter = false;
            if (nd.Kinds.Count > 1)
            {
                Write("SyntaxKind kind");
                hasPreviousParameter = true;
            }

            for (int i = 0, n = nd.Fields.Count; i < n; i++)
            {
                var field = nd.Fields[i];

                if (factoryWithNoAutoCreatableTokenFields.Contains(field))
                {
                    if (hasPreviousParameter)
                        Write(", ");

                    Write("{0} {1}", GetRedPropertyType(field), CamelCase(field.Name));

                    hasPreviousParameter = true;
                }
            }
            WriteLine(")");

            WriteLine("    {");

            Write("      return SyntaxFactory.{0}(", StripPost(nd.Name, "Syntax"));

            bool hasPreviousArgument = false;
            if (nd.Kinds.Count > 1)
            {
                Write("kind");
                hasPreviousArgument = true;
            }

            for (int i = 0, n = nd.Fields.Count; i < n; i++)
            {
                var field = nd.Fields[i];

                if (hasPreviousArgument)
                    Write(", ");

                if (factoryWithNoAutoCreatableTokenFields.Contains(field))
                {
                    // pass supplied parameter on to general factory
                    Write("{0}", CamelCase(field.Name));
                }
                else
                {
                    // pass an auto-created token to the general factory
                    Write("{0}", GetDefaultValue(nd, field));
                }

                hasPreviousArgument = true;
            }

            WriteLine(");");

            WriteLine("    }");
        }

        private Field DetermineMinimalOptionalField(Node nd)
        {
            // first if there is a single list, then choose the list because it would not have been optional
            int listCount = nd.Fields.Count(f => IsAnyNodeList(f.Type));
            if (listCount == 1)
            {
                return nd.Fields.First(f => IsAnyNodeList(f.Type));
            }
            else
            {
                // otherwise, if there is a single optional node, use that..
                int nodeCount = nd.Fields.Count(f => IsNode(f.Type) && f.Type != "SyntaxToken");
                if (nodeCount == 1)
                {
                    return nd.Fields.First(f => IsNode(f.Type) && f.Type != "SyntaxToken");
                }
                else
                {
                    return null;
                }
            }
        }

        private IEnumerable<Field> DetermineMinimalFactoryFields(Node nd)
        {
            // special case to allow a single optional argument if there would have been no arguments
            // and we can determine a best single argument.
            Field allowOptionalField = null;

            var optionalCount = OptionalFactoryArgumentCount(nd);
            if (optionalCount == 0)
            {
                return null; // no fields...
            }

            var requiredCount = RequiredFactoryArgumentCount(nd, includeKind: false);
            if (requiredCount == 0 && optionalCount > 1)
            {
                allowOptionalField = DetermineMinimalOptionalField(nd);
            }

            return nd.Fields.Where(f => IsRequiredFactoryField(nd, f) || allowOptionalField == f);
        }

        // creates a factory with only the required arguments (everything else is defaulted)
        private void WriteRedMinimalFactory(Node nd, bool withStringNames = false)
        {
            var optionalCount = OptionalFactoryArgumentCount(nd);
            if (optionalCount == 0)
                return; // already handled w/ general factory method

            var minimalFactoryfields = new HashSet<Field>(DetermineMinimalFactoryFields(nd));

            if (withStringNames && minimalFactoryfields.Count(f => IsRequiredFactoryField(nd, f) && CanAutoConvertFromString(f)) == 0)
                return; // no string-name overload necessary

            this.WriteLine();

            WriteComment(string.Format("<summary>Creates a new {0} instance.</summary>", nd.Name), "    ");
            Write("    {0} static {1} {2}(", "public", nd.Name, StripPost(nd.Name, "Syntax"));

            bool hasPreviousParameter = false;
            if (nd.Kinds.Count > 1)
            {
                Write("SyntaxKind kind");
                hasPreviousParameter = true;
            }

            for (int i = 0, n = nd.Fields.Count; i < n; i++)
            {
                var field = nd.Fields[i];

                if (minimalFactoryfields.Contains(field))
                {
                    var type = GetRedPropertyType(field);

                    if (IsRequiredFactoryField(nd, field))
                    {
                        if (hasPreviousParameter)
                            Write(", ");

                        if (withStringNames && CanAutoConvertFromString(field))
                        {
                            type = "string";
                        }

                        Write("{0} {1}", type, CamelCase(field.Name));

                        hasPreviousParameter = true;
                    }
                    else
                    {
                        if (hasPreviousParameter)
                            Write(", ");

                        Write("{0} {1} = default({0})", type, CamelCase(field.Name));

                        hasPreviousParameter = true;
                    }
                }
            }
            WriteLine(")");

            WriteLine("    {");

            Write("      return SyntaxFactory.{0}(", StripPost(nd.Name, "Syntax"));

            bool hasPreviousArgument = false;
            if (nd.Kinds.Count > 1)
            {
                Write("kind");
                hasPreviousArgument = true;
            }

            for (int i = 0, n = nd.Fields.Count; i < n; i++)
            {
                var field = nd.Fields[i];

                if (hasPreviousArgument)
                    Write(", ");

                if (minimalFactoryfields.Contains(field))
                {
                    if (IsRequiredFactoryField(nd, field))
                    {
                        if (withStringNames && CanAutoConvertFromString(field))
                        {
                            Write("{0}({1})", GetStringConverterMethod(field), CamelCase(field.Name));
                        }
                        else
                        {
                            Write("{0}", CamelCase(field.Name));
                        }
                    }
                    else
                    {
                        if (IsOptional(field) || IsAnyList(field.Type))
                        {
                            Write("{0}", CamelCase(field.Name));
                        }
                        else
                        {
                            Write("{0} ?? {1}", CamelCase(field.Name), GetDefaultValue(nd, field));
                        }
                    }
                }
                else
                {
                    var defaultValue = GetDefaultValue(nd, field);
                    Write(defaultValue);
                }

                hasPreviousArgument = true;
            }

            WriteLine(");");

            WriteLine("    }");
        }

        private bool CanAutoConvertFromString(Field field)
        {
            return IsIdentifierToken(field) || IsIdentifierNameSyntax(field);
        }

        private bool IsIdentifierToken(Field field)
        {
            return field.Type == "SyntaxToken" && field.Kinds != null && field.Kinds.Count == 1 && field.Kinds[0].Name == "IdentifierToken";
        }

        private bool IsIdentifierNameSyntax(Field field)
        {
            return field.Type == "IdentifierNameSyntax";
        }

        private string GetStringConverterMethod(Field field)
        {
            if (IsIdentifierToken(field))
            {
                return "SyntaxFactory.Identifier";
            }
            else if (IsIdentifierNameSyntax(field))
            {
                return "SyntaxFactory.IdentifierName";
            }
            else
            {
                throw new NotSupportedException();
            }
        }

        /// <summary>
        /// Anything inside a &lt;Comment&gt; tag gets written out (escaping untouched) as the
        /// XML doc comment.  Line breaks will be preserved.
        /// </summary>
        private void WriteComment(string comment, string indent)
        {
            if (comment != null)
            {
                var lines = comment.Split(new string[] { "\r", "\n", "\r\n" }, StringSplitOptions.RemoveEmptyEntries);
                foreach (var line in lines.Where(l => !string.IsNullOrWhiteSpace(l)))
                {
                    WriteLine("{0}/// {1}", indent, line.TrimStart());
                }
            }
        }

        /// <summary>
        /// Anything inside a &lt;Comment&gt; tag gets written out (escaping untouched) as the
        /// XML doc comment.  Line breaks will be preserved.
        /// </summary>
        private void WriteComment(Comment comment, string indent)
        {
            if (comment != null)
            {
                foreach (XmlElement element in comment.Body)
                {
                    string[] lines = element.OuterXml.Split(new string[] { "\r", "\n", "\r\n" }, StringSplitOptions.RemoveEmptyEntries);
                    foreach (string line in lines.Where(l => !string.IsNullOrWhiteSpace(l)))
                    {
                        WriteLine("{0}/// {1}", indent, line.TrimStart());
                    }
                }
            }
        }
    }
}
