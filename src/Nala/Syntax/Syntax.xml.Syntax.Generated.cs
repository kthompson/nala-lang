// <auto-generated />

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading;


namespace Nala.Syntax
{
  /// <summary>Provides the base class from which the classes that represent name syntax nodes are derived. This is an abstract class.</summary>
  public abstract partial class NameSyntax : TypeSyntax
  {
    internal NameSyntax(SyntaxKind kind)
      : base(kind)
    {
    }
  }

  /// <summary>Provides the base class from which the classes that represent simple name syntax nodes are derived. This is an abstract class.</summary>
  public abstract partial class SimpleNameSyntax : NameSyntax
  {
    internal SimpleNameSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    /// <summary>SyntaxToken representing the identifier of the simple name.</summary>
    public abstract SyntaxToken Identifier { get; }
  }

  /// <summary>Class which represents the syntax node for identifier name.</summary>
  public sealed partial class IdentifierNameSyntax : SimpleNameSyntax
  {
    private readonly SyntaxToken identifier;

    internal IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier)
        : base(kind)
    {
        this.SlotCount = 1;
        this.identifier = identifier;
    }

    /// <summary>SyntaxToken representing the keyword for the kind of the identifier name.</summary>
    public override SyntaxToken Identifier 
    {
      get { return this.identifier; }
    }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIdentifierName(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitIdentifierName(this);
    }

    public IdentifierNameSyntax Update(SyntaxToken identifier)
    {
        if (identifier != this.Identifier)
        {
            return SyntaxFactory.IdentifierName(identifier);
        }

        return this;
    }

    public IdentifierNameSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(identifier);
    }
  }

  /// <summary>Class which represents the syntax node for qualified name.</summary>
  public sealed partial class QualifiedNameSyntax : NameSyntax
  {
    private readonly NameSyntax left;
    private readonly SyntaxToken dotToken;
    private readonly SimpleNameSyntax right;

    internal QualifiedNameSyntax(SyntaxKind kind, NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
        : base(kind)
    {
        this.SlotCount = 3;
        this.left = left;
        this.dotToken = dotToken;
        this.right = right;
    }

    /// <summary>NameSyntax node representing the name on the left side of the dot token of the qualified name.</summary>
    public NameSyntax Left 
    {
        get
        {
            return this.left;
        }
    }

    /// <summary>SyntaxToken representing the dot.</summary>
    public SyntaxToken DotToken 
    {
      get { return this.dotToken; }
    }

    /// <summary>SimpleNameSyntax node representing the name on the right side of the dot token of the qualified name.</summary>
    public SimpleNameSyntax Right 
    {
        get
        {
            return this.right;
        }
    }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.left;
            case 2: return this.right;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitQualifiedName(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitQualifiedName(this);
    }

    public QualifiedNameSyntax Update(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
    {
        if (left != this.Left || dotToken != this.DotToken || right != this.Right)
        {
            return SyntaxFactory.QualifiedName(left, dotToken, right);
        }

        return this;
    }

    public QualifiedNameSyntax WithLeft(NameSyntax left)
    {
        return this.Update(left, this.DotToken, this.Right);
    }

    public QualifiedNameSyntax WithDotToken(SyntaxToken dotToken)
    {
        return this.Update(this.Left, dotToken, this.Right);
    }

    public QualifiedNameSyntax WithRight(SimpleNameSyntax right)
    {
        return this.Update(this.Left, this.DotToken, right);
    }
  }

  /// <summary>Provides the base class from which the classes that represent type syntax nodes are derived. This is an abstract class.</summary>
  public abstract partial class TypeSyntax : ExpressionSyntax
  {
    internal TypeSyntax(SyntaxKind kind)
      : base(kind)
    {
    }
  }

  /// <summary>Provides the base class from which the classes that represent expression syntax nodes are derived. This is an abstract class.</summary>
  public abstract partial class ExpressionSyntax : SyntaxNode
  {
    internal ExpressionSyntax(SyntaxKind kind)
      : base(kind)
    {
    }
  }

  public sealed partial class CompilationUnitSyntax : SyntaxNode
  {
    private readonly NamespaceDeclarationSyntax @namespace;
    private readonly SyntaxNode usings;
    private readonly SyntaxNode members;
    private readonly SyntaxToken endOfFileToken;

    internal CompilationUnitSyntax(SyntaxKind kind, NamespaceDeclarationSyntax @namespace, SyntaxNode usings, SyntaxNode members, SyntaxToken endOfFileToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.@namespace = @namespace;
        this.usings = usings;
        this.members = members;
        this.endOfFileToken = endOfFileToken;
    }

    public NamespaceDeclarationSyntax Namespace 
    {
        get
        {
            return this.@namespace;
        }
    }

    public SyntaxList<OpenDirectiveSyntax> Usings 
    {
        get
        {
            return new SyntaxList<OpenDirectiveSyntax>(this.usings);
        }
    }

    public SyntaxList<TopLevelMemberDeclarationSyntax> Members 
    {
        get
        {
            return new SyntaxList<TopLevelMemberDeclarationSyntax>(this.members);
        }
    }

    public SyntaxToken EndOfFileToken 
    {
      get { return this.endOfFileToken; }
    }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.@namespace;
            case 1: return this.usings;
            case 2: return this.members;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCompilationUnit(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitCompilationUnit(this);
    }

    public CompilationUnitSyntax Update(NamespaceDeclarationSyntax @namespace, SyntaxList<OpenDirectiveSyntax> usings, SyntaxList<TopLevelMemberDeclarationSyntax> members, SyntaxToken endOfFileToken)
    {
        if (@namespace != this.Namespace || usings != this.Usings || members != this.Members || endOfFileToken != this.EndOfFileToken)
        {
            return SyntaxFactory.CompilationUnit(@namespace, usings, members, endOfFileToken);
        }

        return this;
    }

    public CompilationUnitSyntax WithNamespace(NamespaceDeclarationSyntax @namespace)
    {
        return this.Update(@namespace, this.Usings, this.Members, this.EndOfFileToken);
    }

    public CompilationUnitSyntax WithUsings(SyntaxList<OpenDirectiveSyntax> usings)
    {
        return this.Update(this.Namespace, usings, this.Members, this.EndOfFileToken);
    }

    public CompilationUnitSyntax WithMembers(SyntaxList<TopLevelMemberDeclarationSyntax> members)
    {
        return this.Update(this.Namespace, this.Usings, members, this.EndOfFileToken);
    }

    public CompilationUnitSyntax WithEndOfFileToken(SyntaxToken endOfFileToken)
    {
        return this.Update(this.Namespace, this.Usings, this.Members, endOfFileToken);
    }

    public CompilationUnitSyntax AddUsings(params OpenDirectiveSyntax[] items)
    {
        return this.WithUsings(this.Usings.AddRange(items));
    }

    public CompilationUnitSyntax AddMembers(params TopLevelMemberDeclarationSyntax[] items)
    {
        return this.WithMembers(this.Members.AddRange(items));
    }
  }

  public sealed partial class NamespaceDeclarationSyntax : SyntaxNode
  {
    private readonly SyntaxToken namespaceKeyword;
    private readonly NameSyntax name;

    internal NamespaceDeclarationSyntax(SyntaxKind kind, SyntaxToken namespaceKeyword, NameSyntax name)
        : base(kind)
    {
        this.SlotCount = 2;
        this.namespaceKeyword = namespaceKeyword;
        this.name = name;
    }

    public SyntaxToken NamespaceKeyword 
    {
      get { return this.namespaceKeyword; }
    }

    public NameSyntax Name 
    {
        get
        {
            return this.name;
        }
    }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 1: return this.name;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitNamespaceDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitNamespaceDeclaration(this);
    }

    public NamespaceDeclarationSyntax Update(SyntaxToken namespaceKeyword, NameSyntax name)
    {
        if (namespaceKeyword != this.NamespaceKeyword || name != this.Name)
        {
            return SyntaxFactory.NamespaceDeclaration(namespaceKeyword, name);
        }

        return this;
    }

    public NamespaceDeclarationSyntax WithNamespaceKeyword(SyntaxToken namespaceKeyword)
    {
        return this.Update(namespaceKeyword, this.Name);
    }

    public NamespaceDeclarationSyntax WithName(NameSyntax name)
    {
        return this.Update(this.NamespaceKeyword, name);
    }
  }

  public sealed partial class OpenDirectiveSyntax : SyntaxNode
  {
    private readonly SyntaxToken openKeyword;
    private readonly NameSyntax name;

    internal OpenDirectiveSyntax(SyntaxKind kind, SyntaxToken openKeyword, NameSyntax name)
        : base(kind)
    {
        this.SlotCount = 2;
        this.openKeyword = openKeyword;
        this.name = name;
    }

    public SyntaxToken OpenKeyword 
    {
      get { return this.openKeyword; }
    }

    public NameSyntax Name 
    {
        get
        {
            return this.name;
        }
    }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 1: return this.name;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOpenDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitOpenDirective(this);
    }

    public OpenDirectiveSyntax Update(SyntaxToken openKeyword, NameSyntax name)
    {
        if (openKeyword != this.OpenKeyword || name != this.Name)
        {
            return SyntaxFactory.OpenDirective(openKeyword, name);
        }

        return this;
    }

    public OpenDirectiveSyntax WithOpenKeyword(SyntaxToken openKeyword)
    {
        return this.Update(openKeyword, this.Name);
    }

    public OpenDirectiveSyntax WithName(NameSyntax name)
    {
        return this.Update(this.OpenKeyword, name);
    }
  }

  public abstract partial class BaseMemberDeclarationSyntax : SyntaxNode
  {
    internal BaseMemberDeclarationSyntax(SyntaxKind kind)
      : base(kind)
    {
    }
  }

  public abstract partial class MemberDeclarationSyntax : BaseMemberDeclarationSyntax
  {
    internal MemberDeclarationSyntax(SyntaxKind kind)
      : base(kind)
    {
    }
  }

  public abstract partial class TopLevelMemberDeclarationSyntax : BaseMemberDeclarationSyntax
  {
    internal TopLevelMemberDeclarationSyntax(SyntaxKind kind)
      : base(kind)
    {
    }
  }

  public sealed partial class TraitDeclarationSyntax : TopLevelMemberDeclarationSyntax
  {
    private readonly SyntaxToken traitKeyword;
    private readonly SimpleNameSyntax name;
    private readonly SyntaxToken openBracketToken;
    private readonly SyntaxNode members;
    private readonly SyntaxToken closeBracketToken;

    internal TraitDeclarationSyntax(SyntaxKind kind, SyntaxToken traitKeyword, SimpleNameSyntax name, SyntaxToken openBracketToken, SyntaxNode members, SyntaxToken closeBracketToken)
        : base(kind)
    {
        this.SlotCount = 5;
        this.traitKeyword = traitKeyword;
        this.name = name;
        this.openBracketToken = openBracketToken;
        this.members = members;
        this.closeBracketToken = closeBracketToken;
    }

    public SyntaxToken TraitKeyword 
    {
      get { return this.traitKeyword; }
    }

    public SimpleNameSyntax Name 
    {
        get
        {
            return this.name;
        }
    }

    /// <summary>SyntaxToken representing open bracket.</summary>
    public SyntaxToken OpenBracketToken 
    {
      get { return this.openBracketToken; }
    }

    public SyntaxList<BaseMemberDeclarationSyntax> Members 
    {
        get
        {
            return new SyntaxList<BaseMemberDeclarationSyntax>(this.members);
        }
    }

    /// <summary>SyntaxToken representing close bracket.</summary>
    public SyntaxToken CloseBracketToken 
    {
      get { return this.closeBracketToken; }
    }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 1: return this.name;
            case 3: return this.members;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTraitDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitTraitDeclaration(this);
    }

    public TraitDeclarationSyntax Update(SyntaxToken traitKeyword, SimpleNameSyntax name, SyntaxToken openBracketToken, SyntaxList<BaseMemberDeclarationSyntax> members, SyntaxToken closeBracketToken)
    {
        if (traitKeyword != this.TraitKeyword || name != this.Name || openBracketToken != this.OpenBracketToken || members != this.Members || closeBracketToken != this.CloseBracketToken)
        {
            return SyntaxFactory.TraitDeclaration(traitKeyword, name, openBracketToken, members, closeBracketToken);
        }

        return this;
    }

    public TraitDeclarationSyntax WithTraitKeyword(SyntaxToken traitKeyword)
    {
        return this.Update(traitKeyword, this.Name, this.OpenBracketToken, this.Members, this.CloseBracketToken);
    }

    public TraitDeclarationSyntax WithName(SimpleNameSyntax name)
    {
        return this.Update(this.TraitKeyword, name, this.OpenBracketToken, this.Members, this.CloseBracketToken);
    }

    public TraitDeclarationSyntax WithOpenBracketToken(SyntaxToken openBracketToken)
    {
        return this.Update(this.TraitKeyword, this.Name, openBracketToken, this.Members, this.CloseBracketToken);
    }

    public TraitDeclarationSyntax WithMembers(SyntaxList<BaseMemberDeclarationSyntax> members)
    {
        return this.Update(this.TraitKeyword, this.Name, this.OpenBracketToken, members, this.CloseBracketToken);
    }

    public TraitDeclarationSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)
    {
        return this.Update(this.TraitKeyword, this.Name, this.OpenBracketToken, this.Members, closeBracketToken);
    }

    public TraitDeclarationSyntax AddMembers(params BaseMemberDeclarationSyntax[] items)
    {
        return this.WithMembers(this.Members.AddRange(items));
    }
  }

  public sealed partial class ObjectDeclarationSyntax : TopLevelMemberDeclarationSyntax
  {
    private readonly SyntaxToken objectKeyword;
    private readonly SimpleNameSyntax name;
    private readonly SyntaxToken openBracketToken;
    private readonly SyntaxNode members;
    private readonly SyntaxToken closeBracketToken;

    internal ObjectDeclarationSyntax(SyntaxKind kind, SyntaxToken objectKeyword, SimpleNameSyntax name, SyntaxToken openBracketToken, SyntaxNode members, SyntaxToken closeBracketToken)
        : base(kind)
    {
        this.SlotCount = 5;
        this.objectKeyword = objectKeyword;
        this.name = name;
        this.openBracketToken = openBracketToken;
        this.members = members;
        this.closeBracketToken = closeBracketToken;
    }

    public SyntaxToken ObjectKeyword 
    {
      get { return this.objectKeyword; }
    }

    public SimpleNameSyntax Name 
    {
        get
        {
            return this.name;
        }
    }

    /// <summary>SyntaxToken representing open bracket.</summary>
    public SyntaxToken OpenBracketToken 
    {
      get { return this.openBracketToken; }
    }

    public SyntaxList<BaseMemberDeclarationSyntax> Members 
    {
        get
        {
            return new SyntaxList<BaseMemberDeclarationSyntax>(this.members);
        }
    }

    /// <summary>SyntaxToken representing close bracket.</summary>
    public SyntaxToken CloseBracketToken 
    {
      get { return this.closeBracketToken; }
    }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 1: return this.name;
            case 3: return this.members;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitObjectDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitObjectDeclaration(this);
    }

    public ObjectDeclarationSyntax Update(SyntaxToken objectKeyword, SimpleNameSyntax name, SyntaxToken openBracketToken, SyntaxList<BaseMemberDeclarationSyntax> members, SyntaxToken closeBracketToken)
    {
        if (objectKeyword != this.ObjectKeyword || name != this.Name || openBracketToken != this.OpenBracketToken || members != this.Members || closeBracketToken != this.CloseBracketToken)
        {
            return SyntaxFactory.ObjectDeclaration(objectKeyword, name, openBracketToken, members, closeBracketToken);
        }

        return this;
    }

    public ObjectDeclarationSyntax WithObjectKeyword(SyntaxToken objectKeyword)
    {
        return this.Update(objectKeyword, this.Name, this.OpenBracketToken, this.Members, this.CloseBracketToken);
    }

    public ObjectDeclarationSyntax WithName(SimpleNameSyntax name)
    {
        return this.Update(this.ObjectKeyword, name, this.OpenBracketToken, this.Members, this.CloseBracketToken);
    }

    public ObjectDeclarationSyntax WithOpenBracketToken(SyntaxToken openBracketToken)
    {
        return this.Update(this.ObjectKeyword, this.Name, openBracketToken, this.Members, this.CloseBracketToken);
    }

    public ObjectDeclarationSyntax WithMembers(SyntaxList<BaseMemberDeclarationSyntax> members)
    {
        return this.Update(this.ObjectKeyword, this.Name, this.OpenBracketToken, members, this.CloseBracketToken);
    }

    public ObjectDeclarationSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)
    {
        return this.Update(this.ObjectKeyword, this.Name, this.OpenBracketToken, this.Members, closeBracketToken);
    }

    public ObjectDeclarationSyntax AddMembers(params BaseMemberDeclarationSyntax[] items)
    {
        return this.WithMembers(this.Members.AddRange(items));
    }
  }

  public sealed partial class ClassDeclarationSyntax : TopLevelMemberDeclarationSyntax
  {
    private readonly SyntaxToken caseKeyword;
    private readonly SyntaxToken classKeyword;
    private readonly SimpleNameSyntax name;
    private readonly SyntaxToken openBracketToken;
    private readonly SyntaxNode members;
    private readonly SyntaxToken closeBracketToken;

    internal ClassDeclarationSyntax(SyntaxKind kind, SyntaxToken caseKeyword, SyntaxToken classKeyword, SimpleNameSyntax name, SyntaxToken openBracketToken, SyntaxNode members, SyntaxToken closeBracketToken)
        : base(kind)
    {
        this.SlotCount = 6;
        this.caseKeyword = caseKeyword;
        this.classKeyword = classKeyword;
        this.name = name;
        this.openBracketToken = openBracketToken;
        this.members = members;
        this.closeBracketToken = closeBracketToken;
    }

    public SyntaxToken CaseKeyword 
    {
        get
        {
            return this.caseKeyword;
        }
    }

    public SyntaxToken ClassKeyword 
    {
      get { return this.classKeyword; }
    }

    public SimpleNameSyntax Name 
    {
        get
        {
            return this.name;
        }
    }

    /// <summary>SyntaxToken representing open bracket.</summary>
    public SyntaxToken OpenBracketToken 
    {
      get { return this.openBracketToken; }
    }

    public SyntaxList<BaseMemberDeclarationSyntax> Members 
    {
        get
        {
            return new SyntaxList<BaseMemberDeclarationSyntax>(this.members);
        }
    }

    /// <summary>SyntaxToken representing close bracket.</summary>
    public SyntaxToken CloseBracketToken 
    {
      get { return this.closeBracketToken; }
    }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 2: return this.name;
            case 4: return this.members;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitClassDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitClassDeclaration(this);
    }

    public ClassDeclarationSyntax Update(SyntaxToken caseKeyword, SyntaxToken classKeyword, SimpleNameSyntax name, SyntaxToken openBracketToken, SyntaxList<BaseMemberDeclarationSyntax> members, SyntaxToken closeBracketToken)
    {
        if (caseKeyword != this.CaseKeyword || classKeyword != this.ClassKeyword || name != this.Name || openBracketToken != this.OpenBracketToken || members != this.Members || closeBracketToken != this.CloseBracketToken)
        {
            return SyntaxFactory.ClassDeclaration(caseKeyword, classKeyword, name, openBracketToken, members, closeBracketToken);
        }

        return this;
    }

    public ClassDeclarationSyntax WithCaseKeyword(SyntaxToken caseKeyword)
    {
        return this.Update(caseKeyword, this.ClassKeyword, this.Name, this.OpenBracketToken, this.Members, this.CloseBracketToken);
    }

    public ClassDeclarationSyntax WithClassKeyword(SyntaxToken classKeyword)
    {
        return this.Update(this.CaseKeyword, classKeyword, this.Name, this.OpenBracketToken, this.Members, this.CloseBracketToken);
    }

    public ClassDeclarationSyntax WithName(SimpleNameSyntax name)
    {
        return this.Update(this.CaseKeyword, this.ClassKeyword, name, this.OpenBracketToken, this.Members, this.CloseBracketToken);
    }

    public ClassDeclarationSyntax WithOpenBracketToken(SyntaxToken openBracketToken)
    {
        return this.Update(this.CaseKeyword, this.ClassKeyword, this.Name, openBracketToken, this.Members, this.CloseBracketToken);
    }

    public ClassDeclarationSyntax WithMembers(SyntaxList<BaseMemberDeclarationSyntax> members)
    {
        return this.Update(this.CaseKeyword, this.ClassKeyword, this.Name, this.OpenBracketToken, members, this.CloseBracketToken);
    }

    public ClassDeclarationSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)
    {
        return this.Update(this.CaseKeyword, this.ClassKeyword, this.Name, this.OpenBracketToken, this.Members, closeBracketToken);
    }

    public ClassDeclarationSyntax AddMembers(params BaseMemberDeclarationSyntax[] items)
    {
        return this.WithMembers(this.Members.AddRange(items));
    }
  }

  public abstract partial class BaseMethodDeclarationSyntax : TopLevelMemberDeclarationSyntax
  {
    internal BaseMethodDeclarationSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    public abstract SyntaxToken ClassKeyword { get; }

    public abstract SimpleNameSyntax Name { get; }

    /// <summary>SyntaxToken representing open bracket.</summary>
    public abstract SyntaxToken OpenBracketToken { get; }

    public abstract SyntaxList<BaseMemberDeclarationSyntax> Members { get; }

    /// <summary>SyntaxToken representing close bracket.</summary>
    public abstract SyntaxToken CloseBracketToken { get; }
  }
}
